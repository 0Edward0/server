package org.domeos.client.kubernetesclient.definitions.v1;
/**
 * Created by anningluo on 2015-12-02.
*/
import com.fasterxml.jackson.annotation.JsonProperty;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Iterator;

// ObjectMeta
// ==========
// Description:
// 	ObjectMeta is metadata that all persisted resources must have, which
// 	includes all objects users must create.
// Variables:
// 	Name                      	Required	Schema         	Default
// 	==========================	========	===============	=======
// 	name                      	false   	string         	       
// 	generateName              	false   	string         	       
// 	namespace                 	false   	string         	       
// 	selfLink                  	false   	string         	       
// 	uid                       	false   	string         	       
// 	resourceVersion           	false   	string         	       
// 	generation                	false   	integer (int64)	       
// 	creationTimestamp         	false   	string         	       
// 	deletionTimestamp         	false   	string         	       
// 	deletionGracePeriodSeconds	false   	integer (int64)	       
// 	labels                    	false   	any            	       
// 	annotations               	false   	any            	       

public class ObjectMeta {
	// Name must be unique within a namespace. Is required when creating
	// resources, although some resources may allow a client to request the
	// generation of an appropriate name automatically. Name is primarily
	// intended for creation idempotence and configuration definition.
	// Cannot be updated. More info:
	// http://kubernetes.io/v1.1/docs/user-guide/identifiers.html#names
	private String name;

	// GenerateName is an optional prefix, used by the server, to generate a
	// unique name ONLY IF the Name field has not been provided. If this field is
	// used, the name returned to the client will be different than the name
	// passed. This value will also be combined with a unique suffix. The
	// provided value has the same validation rules as the Name field, and may
	// be truncated by the length of the suffix required to make the value
	// unique on the server. If this field is specified and the generated name
	// exists, the server will NOT return a 409 - instead, it will either return
	// 201 Created or 500 with Reason ServerTimeout indicating a unique name
	// could not be found in the time allotted, and the client should retry
	// (optionally after the time indicated in the Retry-After header).
	// Applied only if Name is not specified. More info:
	// http://kubernetes.io/v1.1/docs/devel/api-conventions.html#idempotency
	private String generateName;

	// Namespace defines the space within each name must be unique. An empty
	// namespace is equivalent to the "default" namespace, but "default" is
	// the canonical representation. Not all objects are required to be
	// scoped to a namespace - the value of this field for those objects will be
	// empty. Must be a DNS_LABEL. Cannot be updated. More info:
	// http://kubernetes.io/v1.1/docs/user-guide/namespaces.html
	private String namespace;

	// SelfLink is a URL representing this object. Populated by the system.
	// Read-only.
	private String selfLink;

	// UID is the unique in time and space value for this object. It is typically
	// generated by the server on successful creation of a resource and is not
	// allowed to change on PUT operations. Populated by the system.
	// Read-only. More info:
	// http://kubernetes.io/v1.1/docs/user-guide/identifiers.html#uids
	private String uid;

	// An opaque value that represents the internal version of this object
	// that can be used by clients to determine when objects have changed. May
	// be used for optimistic concurrency, change detection, and the watch
	// operation on a resource or set of resources. Clients must treat these
	// values as opaque and passed unmodified back to the server. They may only
	// be valid for a particular resource or set of resources. Populated by the
	// system. Read-only. Value must be treated as opaque by clients and . More
	// info:
	// http://kubernetes.io/v1.1/docs/devel/api-conventions.html#concurrency-control-and-consistency
	private String resourceVersion;

	// A sequence number representing a specific generation of the desired
	// state. Currently only implemented by replication controllers.
	// Populated by the system. Read-only.
	private long generation;

	// CreationTimestamp is a timestamp representing the server time when
	// this object was created. It is not guaranteed to be set in
	// happens-before order across separate operations. Clients may not set
	// this value. It is represented in RFC3339 form and is in UTC. Populated by
	// the system. Read-only. Null for lists. More info:
	// http://kubernetes.io/v1.1/docs/devel/api-conventions.html#metadata
	private String creationTimestamp;

	// DeletionTimestamp is RFC 3339 date and time at which this resource will
	// be deleted. This field is set by the server when a graceful deletion is
	// requested by the user, and is not directly settable by a client. The
	// resource will be deleted (no longer visible from resource lists, and
	// not reachable by name) after the time in this field. Once set, this value
	// may not be unset or be set further into the future, although it may be
	// shortened or the resource may be deleted prior to this time. For
	// example, a user may request that a pod is deleted in 30 seconds. The
	// Kubelet will react by sending a graceful termination signal to the
	// containers in the pod. Once the resource is deleted in the API, the
	// Kubelet will send a hard termination signal to the container. If not
	// set, graceful deletion of the object has not been requested. Populated
	// by the system when a graceful deletion is requested. Read-only. More
	// info:
	// http://kubernetes.io/v1.1/docs/devel/api-conventions.html#metadata
	private String deletionTimestamp;

	// Number of seconds allowed for this object to gracefully terminate
	// before it will be removed from the system. Only set when
	// deletionTimestamp is also set. May only be shortened. Read-only.
	private long deletionGracePeriodSeconds;

	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects. May match selectors of replication
	// controllers and services. More info:
	// http://kubernetes.io/v1.1/docs/user-guide/labels.html
	private Map<String, String> labels;

	// Annotations is an unstructured key value map stored with a resource
	// that may be set by external tools to store and retrieve arbitrary
	// metadata. They are not queryable and should be preserved when
	// modifying objects. More info:
	// http://kubernetes.io/v1.1/docs/user-guide/annotations.html
	private Map<String, String> annotations;

	public ObjectMeta() {
	}
	// for name
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public ObjectMeta putName(String name) {
		this.name = name;
		return this;
	}

	// for generateName
	public String getGenerateName() {
		return generateName;
	}
	public void setGenerateName(String generateName) {
		this.generateName = generateName;
	}
	public ObjectMeta putGenerateName(String generateName) {
		this.generateName = generateName;
		return this;
	}

	// for namespace
	public String getNamespace() {
		return namespace;
	}
	public void setNamespace(String namespace) {
		this.namespace = namespace;
	}
	public ObjectMeta putNamespace(String namespace) {
		this.namespace = namespace;
		return this;
	}

	// for selfLink
	public String getSelfLink() {
		return selfLink;
	}
	public void setSelfLink(String selfLink) {
		this.selfLink = selfLink;
	}
	public ObjectMeta putSelfLink(String selfLink) {
		this.selfLink = selfLink;
		return this;
	}

	// for uid
	public String getUid() {
		return uid;
	}
	public void setUid(String uid) {
		this.uid = uid;
	}
	public ObjectMeta putUid(String uid) {
		this.uid = uid;
		return this;
	}

	// for resourceVersion
	public String getResourceVersion() {
		return resourceVersion;
	}
	public void setResourceVersion(String resourceVersion) {
		this.resourceVersion = resourceVersion;
	}
	public ObjectMeta putResourceVersion(String resourceVersion) {
		this.resourceVersion = resourceVersion;
		return this;
	}

	// for generation
	public long getGeneration() {
		return generation;
	}
	public void setGeneration(long generation) {
		this.generation = generation;
	}
	public ObjectMeta putGeneration(long generation) {
		this.generation = generation;
		return this;
	}

	// for creationTimestamp
	public String getCreationTimestamp() {
		return creationTimestamp;
	}
	public void setCreationTimestamp(String creationTimestamp) {
		this.creationTimestamp = creationTimestamp;
	}
	public ObjectMeta putCreationTimestamp(String creationTimestamp) {
		this.creationTimestamp = creationTimestamp;
		return this;
	}

	// for deletionTimestamp
	public String getDeletionTimestamp() {
		return deletionTimestamp;
	}
	public void setDeletionTimestamp(String deletionTimestamp) {
		this.deletionTimestamp = deletionTimestamp;
	}
	public ObjectMeta putDeletionTimestamp(String deletionTimestamp) {
		this.deletionTimestamp = deletionTimestamp;
		return this;
	}

	// for deletionGracePeriodSeconds
	public long getDeletionGracePeriodSeconds() {
		return deletionGracePeriodSeconds;
	}
	public void setDeletionGracePeriodSeconds(long deletionGracePeriodSeconds) {
		this.deletionGracePeriodSeconds = deletionGracePeriodSeconds;
	}
	public ObjectMeta putDeletionGracePeriodSeconds(long deletionGracePeriodSeconds) {
		this.deletionGracePeriodSeconds = deletionGracePeriodSeconds;
		return this;
	}

	// for labels
	public Map<String, String> getLabels() {
		return labels;
	}
	public void setLabels(Map<String, String> labels) {
		this.labels = labels;
	}
	public ObjectMeta putLabels(Map<String, String> labels) {
		this.labels = labels;
		return this;
	}

	// for annotations
	public Map<String, String> getAnnotations() {
		return annotations;
	}
	public void setAnnotations(Map<String, String> annotations) {
		this.annotations = annotations;
	}
	public ObjectMeta putAnnotations(Map<String, String> annotations) {
		this.annotations = annotations;
		return this;
	}

	public String formatLikeYaml(String prefix, String unitPrefix, String firstLinePrefix) {
		String tmpStr = "";
		if (name != null) {
			tmpStr += firstLinePrefix + "name: " + name;
		}
		if (generateName != null) {
			tmpStr += "\n" + prefix + "generateName: " + generateName;
		}
		if (namespace != null) {
			tmpStr += "\n" + prefix + "namespace: " + namespace;
		}
		if (selfLink != null) {
			tmpStr += "\n" + prefix + "selfLink: " + selfLink;
		}
		if (uid != null) {
			tmpStr += "\n" + prefix + "uid: " + uid;
		}
		if (resourceVersion != null) {
			tmpStr += "\n" + prefix + "resourceVersion: " + resourceVersion;
		}
		tmpStr += "\n" + prefix + "generation: " + generation;
		if (creationTimestamp != null) {
			tmpStr += "\n" + prefix + "creationTimestamp: " + creationTimestamp;
		}
		if (deletionTimestamp != null) {
			tmpStr += "\n" + prefix + "deletionTimestamp: " + deletionTimestamp;
		}
		tmpStr += "\n" + prefix + "deletionGracePeriodSeconds: " + deletionGracePeriodSeconds;
		if (labels != null) {
			tmpStr += "\n" + prefix + "labels:";
			Iterator<Map.Entry<String, String>> iter = labels.entrySet().iterator();
			while (iter.hasNext()) {
				Map.Entry<String, String> entry = iter.next();
				tmpStr += "\n" + prefix + unitPrefix + entry.getKey() + ": " + entry.getValue();
			}
		}
		if (annotations != null) {
			tmpStr += "\n" + prefix + "annotations:";
			Iterator<Map.Entry<String, String>> iter = annotations.entrySet().iterator();
			while (iter.hasNext()) {
				Map.Entry<String, String> entry = iter.next();
				tmpStr += "\n" + prefix + unitPrefix + entry.getKey() + ": " + entry.getValue();
			}
		}
		return tmpStr;
	}



	public String toString() {
		return this.formatLikeYaml("", "\t", "");
	}

}